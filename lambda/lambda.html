<!DOCTYPE html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>λ</title>
    <link rel="icon" type="image/x-icon" href="./favicon.ico">
    <link rel="stylesheet" href="../style.css">
    <style>
        :root {
            --red: #ef233c;
            --darkred: #c00424;
            --platinum: #e5e5e5;
            --black: #2b2d42;
            --white: #fff;
            --thumb: #edf2f4;
            --green: #23ef71;
            --darkgreen: #04c059;
            --blue: #239aef;
        }

        * {
            box-sizing: border-box;
            padding: 0;
            margin: 0;
        }

        body {
            font: 16px / 24px "Rubik", sans-serif;
            color: var(--black);
            background: var(--platinum);
            margin: 50px 0;
        }

        .container {
            max-width: 800px;
            padding: 0 15px;
            margin: 0 auto;
        }

        .cards {
            display: flex;
            padding: 25px 0px;
            list-style: none;
            overflow-x: scroll;
            scroll-snap-type: x mandatory;
        }

        .card {
            display: flex;
            flex-direction: column;
            flex: 0 0 50%;
            flex-basis: calc(100% - 10px);
            padding: 5% 15% 10%;
            margin-right: 40px;
            background: var(--white);
            border-radius: 12px;
            box-shadow: 0 5px 15px rgba(0,0,0,20%);
            scroll-snap-align: center;
            transition: all 0.2s;
            position: relative;
        }

        .card .card-link-wrapper {
            margin-top: auto;
        }

        .cards::-webkit-scrollbar {
            height: 12px;
        }

        .cards::-webkit-scrollbar-thumb,
        .cards::-webkit-scrollbar-track {
            border-radius: 90px;
        }

        .cards::-webkit-scrollbar-thumb {
            background: var(--darkred);
        }

        .cards::-webkit-scrollbar-track {
            background: var(--thumb);
        }

        .scroll-buttons {
            position: absolute;
            bottom: 10px;
            /* transform: translateX(150%); */
            display: flex;
            align-self: center;
            gap: 50px;
        }

        .scroll-button {
            padding: 10px 15px;
            border: none;
            border-radius: 50px;
            background: var(--red);
            color: var(--white);
            font-size: 14px;
            cursor: pointer;
            transition: background 0.2s;
        }

        .scroll-button:hover {
            background: var(--darkred);
        }

        .code-container {
            max-width: 800px;
            padding: 10px 15px;
            margin: 0 auto;
            display: flex;
        }

        .function-definition {
            background: var(--white);
            border-radius: 10px;
            border-color: var(--platinum);
            margin: 0 auto;
            padding: 10px;
            resize: none;
            box-shadow: 0 5px 15px rgba(0,0,0,20%);
            width: 50%;
        }

        .function-definition:focus {
            outline: none;
        }

        .function-call {
            display: flex;
            flex-direction: column;
            width: 50%;
            padding: 0 5px;
        }

        .function-call-history {
            background: var(--black);
            color: var(--platinum);
            border-radius: 10px;
            margin: 0 0 4px;
            padding: 10px;
            resize: none;
            box-shadow: 0 5px 15px rgba(0,0,0,20%);
            width: calc(100% - 5px);
            height: auto;
        }

        .function-call-history:focus {
            outline: none;
        }

        .function-call-history::-webkit-scrollbar {
            height: 12px;
        }

        .function-call-history::-webkit-scrollbar-thumb,
        .function-call-history::-webkit-scrollbar-track {
            border-radius: 90px;
        }

        .function-call-history::-webkit-scrollbar-thumb {
            background: var(--darkred);
        }

        .function-call-history::-webkit-scrollbar-track {
            background: var(--thumb);
        }

        .function-call-input {
            background: var(--black);
            color: var(--platinum);
            border-radius: 10px;
            margin: 0 auto;
            padding: 10px;
            resize: none;
            box-shadow: 0 5px 15px rgba(0,0,0,20%);
            width: calc(80% - 5px);
        }

        .function-call-input:focus {
            outline: none;
        }

        .function-call-run {
            padding: 10px 15px;
            width: calc(20% - 5px);
            /* border: none; */
            border-color: var(--black);
            border-style: solid;
            border-radius: 10px;
            background: var(--green);
            color: var(--white);
            font-size: 12px;
            cursor: pointer;
            box-shadow: 0 5px 15px rgba(0,0,0,20%);
            transition: background 0.2s;
        }

        .function-call-run:hover {
            background: var(--darkgreen);
        }

        .red-button {
            padding: 10px 15px;
            border: none;
            border-radius: 50px;
            background: var(--red);
            color: var(--white);
            font-size: 14px;
            cursor: pointer;
            transition: background 0.2s;
        }

        .red-button:hover {
            background: var(--darkred);
        }

        .spoiler {
            display: inline;
            margin-bottom: 2px;
            width: auto;
            background: var(--black);
        }

        .spoiler:hover {
            /* background: var(--platinum); */
            color: var(--white);
        }

    </style>
</head>
<body>
    <div id="HOME">
        <a href="../homepage.html">
            <img src="https://i.kym-cdn.com/entries/icons/original/000/000/142/feelsgoodman.png" width="40" height="20">
        </a>
    </div>
    <div class="container">
        <h2>λ-calculus</h2>
        <ul class="cards">
            <li class="card">
                <div>
                    <h3 class="card-title">λ-calculus</h3>
                    <div class="card-content">
                        Lambda-calculus (lambdakalkyl) är ett matematiskt system för att beskriva beräkningar.<br> 
                        <br>
                        Teorin går ut på att utföra operationer på speciella matematiska formler, så kallade λ-termer / λ-uttryck.<br>
                        <br>
                        λ-calculus skapades av Alonzo Church 1930 och ligger till grund för den funktionella-programmeringen.<br> 
                        <br>
                        λ-calculus kan ses som det minsta universella programmeringsspråket.<br>
                    </div>
                </div>
                <div class="scroll-buttons">
                    <button class="scroll-button backward">←</button>
                    <button class="scroll-button forward">→</button>
                </div>
            </li>
            <li class="card">
                <div>
                    <h3 class="card-title">λ-termer</h3>
                    <div class="card-content">
                        Det finns 3 olika former av λ-termer: <br>
                        <ul>
                            <div style="border-color: var(--red); border-style: dashed; padding-left: 20px;">
                                <li>Variabler: x, y, z</li>
                                &emsp;Representerar en parameter.
                            </div>
                            <div style="border-color: var(--green); border-style: dashed; padding-left: 20px;">
                                <li>Abstraktioner: λx<b>.</b>N</li>
                                &emsp;Där N är en λ-term och punkten visar vart funktionskroppen börjar.<br>
                                &emsp;T.ex: λx<b>.</b>x är en funktion som tar argumentet x och returnerar x.<br>
                                &emsp;&emsp;&emsp;f(x) = x<br>
                            </div>
                            <div style="border-color: var(--blue); border-style: dashed; padding-left: 20px;">
                                <li>Applikation: N M</li>
                                &emsp;Här kallar vi funktionen N med argumentet M. N och M är λ-termer.<br>
                                &emsp;&emsp;&emsp;N(M)<br>
                            </div>
                        </ul>
                    </div>
                </div>
                <div class="scroll-buttons">
                    <button class="scroll-button backward">←</button>
                    <button class="scroll-button forward">→</button>
                </div>
            </li>
            <li class="card">
                <div>
                    <h3 class="card-title">Syntax-regler</h3>
                    <div class="card-content">
                        <ul>
                            <li>Gruppering görs med hjälp av paranteser:</li>
                            &emsp;(λx.x) ((λy.y) z)<br>
                            <li>Abstraktioner är höger-associativa:</li>
                            &emsp;λx.N M = λx.(N M) ≠ (λx.N) M<br>
                            <li>Applikationer är vänster-associativa:</li>
                            &emsp;A B C = (A B) C ≠ A (B C)<br>
                        </ul>
                    </div>
                </div>
                <div class="scroll-buttons">
                    <button class="scroll-button backward">←</button>
                    <button class="scroll-button forward">→</button>
                </div>
            </li>
            <li class="card">
                <div>
                    <h3 class="card-title">Fria och bundna variabler</h3>
                    <div class="card-content">
                        Om vi tar en λ-term, t.ex:<br>
                        λxy <b>.</b> x y z&emsp;=&emsp;λx <b>.</b> λy <b>.</b> x y z &ensp;(Uttrycken är två sätt att skriva samma sak).<br>
                        Kan vi se att <b>x</b> och <b>y</b> är argument till skillnad från <b>z</b>.<br>
                        Här är <b>x</b> och <b>y</b> bundna variabler medan <b>z</b> är en fri variabel.<br>
                        På samma sätt:<br>
                        λx <b>.</b> z λy <b>.</b> λz <b>.</b> x y<br>
                        Där <b>x</b> och <b>y</b> är bundna variabler och <b>z</b> än en gång är en fri variabel eftersom den förekommer innan sitt funktionshuvud.<br>
                        I λ-calculus är uttryck med fria variabler tillåtna men vi kommer inte (kunna) använda dessa här.<br>
                    </div>
                </div>
                <div class="scroll-buttons">
                    <button class="scroll-button backward">←</button>
                    <button class="scroll-button forward">→</button>
                </div>
            </li>
            <li class="card">
                <div>
                    <h3 class="card-title">Transformationer</h3>
                    <div class="card-content">
                        En stor del av λ-calculus är att transformera λ-uttryck.<br>
                        Det finns tre olika transformationer:
                        <ul>
                            <div style="border-color: var(--red); border-style: dashed; padding-left: 20px;">
                                <li>α-konversion: Namnbyte av (bundna) variabler.</li>
                                &emsp;(λx <b>.</b> x) = (λy <b>.</b> y)
                            </div>
                            <div style="border-color: var(--green); border-style: dashed; padding-left: 20px;">
                                <li>β-reduktion: Funktionsanrop.</li>
                                &emsp;(λx <b>.</b> x) y → [x := y] → y<br>
                                &emsp;(λx <b>.</b> x z) (λy <b>.</b> y) → [x := (λy <b>.</b> y)] → (λy <b>.</b> y) z → [y := z] → z<br>
                            </div>
                            <div style="border-color: var(--blue); border-style: dashed; padding-left: 20px;">
                                <li>η-reduktion: En form av förenkling.</li>
                                &emsp;λx <b>.</b> <b>F</b> x&emsp;Kan η-reduceras till <b>F</b> då (λx <b>.</b> <b>F</b> x) N = <b>F</b> N<br>
                                &emsp;Här måste x vara en bunden variabel för att regeln ska gälla.
                            </div> 
                        </ul>

                    </div>
                </div>
                <div class="scroll-buttons">
                    <button class="scroll-button backward">←</button>
                    <button class="scroll-button forward">→</button>
                </div>
            </li>
            <li class="card">
                <div>
                    <h3 class="card-title">Javascript</h3>
                    <div class="card-content">
                        Javascript är ett objektorienterat språk designat för att köras i webbläsare för att lägga till funktionalitet till webbsidor.<br>
                        <br>
                        Javascript stödjer lambda-funtioner vilket gör att man kan skriva lambda-calculus här i webbläsaren.<br>
                        <br>
                        Det enda undantaget är att fria variabler inte stöds.<br>
                    </div>
                </div>
                <div class="scroll-buttons">
                    <button class="scroll-button backward">←</button>
                    <button class="scroll-button forward">→</button>
                </div>
            </li>
            <li class="card">
                <div>
                    <h3 class="card-title">Vad är rutorna där nere?</h3>
                    <div class="card-content">
                        Jag har skrivit denna sida för att kunna definiera och köra λ-funtioner.<br>
                        I den stora vita rutan definieras funktioner, som kan ses om du trycker på demo-knappen.<br>
                        Den nedre mörka rutan är prompten, där kallas funktionerna.<br>
                        Den övre mörka rutan är loggen, där hamnar outputen från prompten.<br>
                        Koden körs med <b>ENTER</b> i prompten eller med den <b>gröna knappen</b>.<br>
                        Börja med att trycka på den gröna knappen och kolla outputen i loggen.<br>
                        Sen kan du testa att köra <b>ADD(2)(3)</b> i prompten och <b>CURRIED(10)</b><br>
                        <br>
                        <button class="red-button" onclick='
                            codeDefinitions.value = `PRINT = () => "Hello, World!"\nADD = (a) => (b) => a + b\nCURRIED = ADD(5)`;
                            codePrompt.value = "PRINT()";
                        '>Tryck här för ett demo</button>
                        <button class="red-button" onclick="
                            codeDefinitions.value = '';
                            codePrompt.value = '';
                            codeLog.value = '';
                        ">Tryck här när du testat färdigt</button>
                    </div>
                </div>
                <div class="scroll-buttons">
                    <button class="scroll-button backward">←</button>
                    <button class="scroll-button forward">→</button>
                </div>
            </li>
            <li class="card">
                <div>
                    <h3 class="card-title">Pil-notation</h3>
                    <div class="card-content">
                        En λ-funktion skrivs som sagt i λ-calculus som:<br>
                        λ [argument] <b>.</b> [funktionskropp]&emsp;&emsp;Ex. λx<b>.</b>x<br>
                        Vilket i Javascript skrivs som:<br>
                        <b>(argument) => funktionskropp</b>&emsp;&emsp;Ex. 
                        <b>(x)=> x</b><br>
                        För att kunna använda vår funktion kan vi namnge den när vi skapar den:<br>
                        <b>A = (x) => x</b><br>
                        Och vi använder den genom att köra <b>A</b> med ett värde (Applikation).<br>
                        T.ex:&emsp;<b>A(1)</b><br>
                        <br>
                        <button class="red-button" onclick="
                            codeDefinitions.value += 'A = (a) => a\n';
                            codePrompt.value = 'A(1)';
                        ">Testa Själv</button>
                    </div>
                </div>
                <div class="scroll-buttons">
                    <button class="scroll-button backward">←</button>
                    <button class="scroll-button forward">→</button>
                </div>
            </li>
            <li class="card">
                <div>
                    <h3 class="card-title">Kombinatorer</h3>
                    <div class="card-content">
                        Det var väl inte så svårt?<br>
                        <br>
                        Nu är det dags att testa att implementera några olika kombinatorer för att se vad dom gör och hur dom fungerar.<br>
                        <br>
                        En kombinator är bara en lambda-term utan fria variabler.
                        <br>
                        Vi börjar med att ta bort det förra exemplet:<br>
                        <br>
                        <button class="red-button" onclick="
                            codeDefinitions.value = '';
                            codePrompt.value = '';
                            codeLog.value = '';
                        ">Rensa</button>
                    </div>
                </div>
                <div class="scroll-buttons">
                    <button class="scroll-button backward">←</button>
                    <button class="scroll-button forward">→</button>
                </div>
            </li>
            <li class="card">
                <div>
                    <h3 class="card-title">Identitet</h3>
                    <div class="card-content">
                        Den lättaste kombinatorn är <b>Identitet</b> och vi beteckar den nu med stora i.<br>
                        <br>
                        Den skrivs i λ-calculus som:<br>
                        I = λ a <b>.</b> a<br>
                        Vilket betyder att den i Javascript skrivs som:<br>
                        <b>I = (a) => a</b><br>
                        Testa att köra den med lite olika argument:<br>
                        T.ex:&emsp;<b>I(11)</b>, <b>I(true)</b>, <b>I("Hej")</b>, <b>I(I(17))</b><br>
                        <br>
                        <button class="red-button" onclick="
                            codeDefinitions.value += 'I = (a) => a\n';
                            codePrompt.value = 'I(11)';
                        ">Testa Själv</button>
                    </div>
                </div>
                <div class="scroll-buttons">
                    <button class="scroll-button backward">←</button>
                    <button class="scroll-button forward">→</button>
                </div>
            </li>
            <li class="card">
                <div>
                    <h3 class="card-title">K-kombinatorn</h3>
                    <div class="card-content">
                        Den andra kombinatorn vi testar är lite svårare.<br>
                        Den skrivs som:<br>
                        <b>λ:</b> K = λ a <b>.</b> λ b <b>.</b> a &emsp;&emsp;<b>JS: K = (a) => (b) => a</b><br>
                        <br>
                        Den tar två argument men returnerar bara det första.<br>
                        Men vad kan det vara bra för?<br>
                        <br>
                        Ex:&emsp;<b>K('a')('b'), K(true)(false)</b><br>
                        <br>
                        <button class="red-button" onclick="
                            codeDefinitions.value += 'K = (a) => (b) => a\n';
                            codePrompt.value = `K('a')('b')`;
                        ">Testa Själv</button>
                    </div>
                </div>
                <div class="scroll-buttons">
                    <button class="scroll-button backward">←</button>
                    <button class="scroll-button forward">→</button>
                </div>
            </li>
            <li class="card">
                <div>
                    <h3 class="card-title">KI-kombinatorn</h3>
                    <div class="card-content">
                        Den tredje kombinatorn är en kombination av dom två tidigare.<br>
                        Den skrivs som:<br>
                        <b>λ:</b> KI = λ a <b>.</b> λ b <b>.</b> b &emsp;&emsp;<b>JS: KI = K(I)</b><br>
                        Alternativt:&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&ensp;<b>KI = (a) => (b) => b</b><br>
                        <br>
                        Nu ignorerar den det första argumentet och returnera det andra.<br>
                        <br>
                        Ex:&emsp;<b>KI('a')('b'), KI(true)(false)</b><br>
                        <br>
                        <button class="red-button" onclick="
                            codeDefinitions.value += 'KI = K(I)\n';
                            codePrompt.value = `KI('a')('b')`;
                        ">Testa Själv</button>
                    </div>
                </div>
                <div class="scroll-buttons">
                    <button class="scroll-button backward">←</button>
                    <button class="scroll-button forward">→</button>
                </div>
            </li>
            <li class="card">
                <div>
                    <h3 class="card-title">C-kombinatorn</h3>
                    <div class="card-content">
                        Den fjärde kombinatorn tar nu tre argument och skrivs som:<br>
                        <b>λ:</b> C = λ f <b>.</b> λ a <b>.</b> λ b <b>.</b> f b a &emsp;&emsp;<b>JS: C = (f) => (a) => (b) => f(b)(a)</b><br>
                        <br>
                        Vi tar en funktion och två argument och kallar funktionen med argumenten i omvänd ordning.<br>
                        Ex:&emsp;<b>C(K)('a')('b'), C(KI)('a')('b'), C(C(K))('a')('b')</b><br>
                        Kan du list ut vad som händer med C(K) och C(KI)?<br>
                        Tjuvkika inte: 
                        <div class="spoiler"><b>C(K) = KI</b>, <b>C(KI) = K</b>, Känner du igen detta beteende?</div><br>
                        <br>
                        <button class="red-button" onclick="
                            codeDefinitions.value += 'C = (f) => (a) => (b) => f(b)(a)\n';
                            codePrompt.value = `C(K)('a')('b')`;
                        ">Testa Själv</button>
                    </div>
                </div>
                <div class="scroll-buttons">
                    <button class="scroll-button backward">←</button>
                    <button class="scroll-button forward">→</button>
                </div>
            </li>
            <li class="card">
                <div>
                    <h3 class="card-title">M-kombinatorn</h3>
                    <div class="card-content">
                        Den femte kombinatorn är lite esoterisk:<br>
                        <b>λ:</b> M = λ f <b>.</b> f f &emsp;&emsp;<b>JS: M = (f) => f(f)</b><br>
                        <br>
                        Denna är alltså "själv-applikation". Vi tar en funktion och kallar argumentet med argumentet.
                        Den är svårare att testa, M(M) t.ex. blir M(M(M(M(...)))) alltså en oändlig rekursion som såklart misslyckas praktiskt när callstacken fylls upp.<br>
                        Ex:&emsp;<b>M(I)('a')</b>, <b>M(K)('a')('b')('c')</b>, <b>M(KI)('a')</b><br>
                        <div class="spoiler">M(I) = I(I) = I, M(K) = λabc.b, M(KI) = I</div>
                        <br>
                        <button class="red-button" onclick="
                            codeDefinitions.value += 'M = (f) => f(f)\n';
                            codePrompt.value = `M(I)('a')`;
                        ">Testa Själv</button>
                    </div>
                </div>
                <div class="scroll-buttons">
                    <button class="scroll-button backward">←</button>
                    <button class="scroll-button forward">→</button>
                </div>
            </li>
            <li class="card">
                <div>
                    <h3 class="card-title">Minsta universella programmeringsspråket</h3>
                    <div class="card-content">
                        På första sliden skrev jag att λ-calculus kan ses som det minsta universella programmeringsspråket.<br>
                        Men än så länge har vi bara sett ett gäng funktioner som fungerar lite olika.<br>
                        <br>
                        Nu är det dags att använda dom tidigare definierade kombinatorerna.<br>
                        Om du har alla hittills kan du gå vidare till nästa slide.<br>
                        <br>
                        Annars kan du plocka alla definitioner här:<br>
                        <button class="red-button" onclick="
                            codeDefinitions.value = 'I  = (a) => a\nK  = (a) => (b) => a\nKI = K(I)\nC  = (f) => (a) => (b) => f(b)(a)\nM  = (f) => f(f)\n';
                        ">Alla definitioner</button>
                    </div>
                </div>
                <div class="scroll-buttons">
                    <button class="scroll-button backward">←</button>
                    <button class="scroll-button forward">→</button>
                </div>
            </li>
            <li class="card">
                <div>
                    <h3 class="card-title">Boolesk logik</h3>
                    <div class="card-content">
                        För att implementera logik behöver vi ett värden som symboliserar sant och falskt.
                        I tidigare exempel används Javascripts inbyggda <b>true</b> och <b>false</b> men det duger inte här, vi vill uttrycka dem i form av funktioner.<br>
                        Kommer du ihåg exemplet från C-kombinatorn då vi såg att:<br>
                        <b>C(K) = KI</b> och <b>C(KI) = K</b> ?<br>
                        Det ser ju ut som en ganska bra start, då kan vi kalla <b>K</b> för <b>TRUE</b>, <b>KI</b> för <b>FALSE</b> och <b>NOT</b> för <b>C</b>.<br>
                        Testa: <b>NOT(FALSE)('sant')('falskt')</b>, <b>NOT(TRUE)('sant')('falskt')</b><br>
                        <button class="red-button" onclick="
                            codeDefinitions.value += '\nTRUE = K\nFALSE = KI\nNOT = C\n';
                            codePrompt.value = `NOT(FALSE)('sant')('falskt')`;
                        ">Kopiera</button>
                    </div>
                </div>
                <div class="scroll-buttons">
                    <button class="scroll-button backward">←</button>
                    <button class="scroll-button forward">→</button>
                </div>
            </li>
            <li class="card">
                <div>
                    <h3 class="card-title">Boolesk logik 2</h3>
                    <div class="card-content">
                        Som du kan se om du kör / körde <b>NOT(FALSE)('sant')('falskt')</b> är att vi lägger till <b>'sant'</b> och <b>'falskt'</b>.<br>
                        Det är för att testa den resulterande funktionen som kommer β-reduceras till <b>K</b> eller <b>KI</b>.<br>
                        För att göra det lättare att läsa definierar vi <b>IF = (a) => I(a)('sant')('falskt')</b><br>
                        Men logiken blir lite begränsad av att bara ha <b>TRUE</b>, <b>FALSE</b> och <b>NOT</b> så vi lägger till:<br>
                        <b>OR = M</b> &emsp; och &emsp; <b>AND = (a) => (b) => I(a)(b)(FALSE)</b>.<br>
                        Testa: <b>IF(AND(NOT(FALSE))(OR(NOT(TRUE))(TRUE)))</b>
                        <br>
                        <button class="red-button" onclick="
                            codeDefinitions.value += `IF = (a) => I(a)('sant')('falskt')\nOR = M\nAND = (a) => (b) => I(a)(b)(FALSE)\n`;
                            codePrompt.value = 'IF(AND(NOT(FALSE))(OR(NOT(TRUE))(TRUE)))';
                        ">Testa</button>
                    </div>
                </div>
                <div class="scroll-buttons">
                    <button class="scroll-button backward">←</button>
                    <button class="scroll-button forward">→</button>
                </div>
            </li>
            <li class="card">
                <div>
                    <h3 class="card-title">Boolesk logik 3</h3>
                    <div class="card-content">
                        Nu har vi alla byggstenar för att utföra logik men här är resten t.ex:<br>
                        <b>NAND</b>, <b>NOR</b>, <b>XOR</b> och <b>XNOR</b>.<br>
                        <br>
                        <b>NAND = (a) => (b) => NOT(AND(a)(b))</b><br>
                        <b>NOR = <div class="spoiler">(a) => (b) => NOT(OR(a)(b))</div></b><br>
                        <b>XOR = (a) => (b) => OR(AND(a)(NOT(b)))(AND(NOT(a))(b))</b><br>
                        <b>&emsp;&ensp;&emsp;= (a) => (b) => I(a)(NOT(b))(b)</b><br>
                        <b>XNOR = <div class="spoiler">(a) => (b) => NOT(XOR(a)(b))</div></b><br>
                        <br>
                        <button class="red-button" onclick="
                            codeDefinitions.value += 'NAND = (a) => (b) => NOT(AND(a)(b))\nNOR = (a) => (b) => NOT(OR(a)(b))\nXOR = (a) => (b) => I(a)(NOT(b))(b)\nXNOR = (a) => (b) => NOT(XOR(a)(b))\n';
                            codePrompt.value = 'IF(XNOR(TRUE)(FALSE))';
                        ">Testa</button>
                    </div>
                </div>
                <div class="scroll-buttons">
                    <button class="scroll-button backward">←</button>
                    <button class="scroll-button forward">→</button>
                </div>
            </li>
            <li class="card">
                <div>
                    <h3 class="card-title">Boolesk logik 4</h3>
                    <div class="card-content">
                        I boolesk algebra behöver vi egentligen bara <b>NAND</b> för att kunna utföra alla booleska operationer.<br>
                        <b>
                        NAND = (a) => (b) => a(b)(FALSE)(FALSE)(TRUE)<br>
                        (a) => NAND(a)(a) = NOT(a)<br>
                        (a) => (b) => NOT(NAND(a)(b)) = AND(a)(b)<br>
                        (a) => (b) => NAND(NOT(a))(NOT(b)) = OR(a)(b)</b> (DeMorgan)<br>
                        osv. Testa att implementera och köra dem om du känner för det.<br>
                        Tryck sen på <b>börja om</b>-knappen innan du går vidare.<br>
                        <br>
                        <button class="red-button" onclick="
                            codeDefinitions.value = `TRUE = (a) => (b) => a\nFALSE = (a) => (b) => b\nIF = (a) => a('sant')('falskt')\n\nNAND = (a) => (b) => a(b)(FALSE)(FALSE)(TRUE)\nNOT = (a) => NAND(a)(a)\nAND = (a) => (b) => NOT(NAND(a)(b))\nOR = (a) => (b) => NAND(NOT(a))(NOT(b))\n`;
                            codePrompt.value = 'IF(OR(TRUE)(AND(TRUE)(FALSE)))';
                        ">Om du vill testa först</button>
                        <button class="red-button" onclick="
                            codeDefinitions.value = '';
                            codePrompt.value = '';
                            codeLog.value = '';
                        ">Annars börjar vi om från scratch</button>
                    </div>
                </div>
                <div class="scroll-buttons">
                    <button class="scroll-button backward">←</button>
                    <button class="scroll-button forward">→</button>
                </div>
            </li>
            <li class="card">
                <div>
                    <h3 class="card-title">B C K W</h3>
                    <div class="card-content">
                        Vi såg nyss att bara <b>NAND</b> kan genera all boolesk algebra.<br>
                        Haskell Curry listade ut att något liknande gällde för λ-calculus med.<br>
                        Hans system bestod av:<br>
                        <b>
                            B = (x) => (y) => (z) => x(y(z))<br>
                            C = (x) => (y) => (z) => x(z)(y)<br>
                            K = (x) => (y) => x<br>
                            W = (x) => (y) => x(y)(y)<br>
                        </b>
                        Genom att kombinera dessa kan vi generera <b>ALLA</b> möjliga λ-termer.<br>
                        <b>I = W(K), KI = K(W(K)) = B(K)(W)(K) och M = W(W(K)) = B(W)(W)(K)</b><br>
                        <button class="red-button" onclick="
                        codeDefinitions.value = `B = (x) => (y) => (z) => x(y(z))\nC = (x) => (y) => (z) => x(z)(y)\nK = (x) => (y) => x\nW = (x) => (y) => x(y)(y)\n\nI = W(K)\nKI = B(K)(W)(K)\nM = B(W)(W)(K)\n`;
                            codePrompt.value = `M(KI)('a')`;
                        ">Testa</button>
                    </div>
                </div>
                <div class="scroll-buttons">
                    <button class="scroll-button backward">←</button>
                    <button class="scroll-button forward">→</button>
                </div>
            </li>
            <li class="card">
                <div>
                    <h3 class="card-title">S K I</h3>
                    <div class="card-content">
                        Vi nöjer oss inte där, vi kan korta ner systemet ännu mer!<br>
                        Genom att endast definiera:<br>
                        <b>
                            S = (x) => (y) => (z) => x(z)(y(z))<br>
                            K = (x) => (y) => x<br>
                            I = (x) => x<br>
                        </b>
                        Med dessa kan vi skapa:<br>
                        <b>
                            KI = K(I) &emsp;&emsp;&emsp;&ensp;&nbsp;
                            M = S(I)(I)<br>
                            B = S(K(S))(K) &emsp;
                            C = S(S(K(S(K(S))(K)))(S))(K(K))<br>
                            W = S(S)(S(K))<br>
                        </b>
                        <button class="red-button" onclick="
                        codeDefinitions.value = `B = (x) => (y) => (z) => x(y(z))\nC = (x) => (y) => (z) => x(z)(y)\nK = (x) => (y) => x\nW = (x) => (y) => x(y)(y)\n\nI = W(K)\nKI = B(K)(W)(K)\nM = B(W)(W)(K)\n`;
                            codePrompt.value = `M(KI)('a')`;
                        ">Testa</button>
                    </div>
                </div>
                <div class="scroll-buttons">
                    <button class="scroll-button backward">←</button>
                    <button class="scroll-button forward">→</button>
                </div>
            </li>
        </ul>
    </div>
    <div class="code-container">
        <textarea class="function-definition" id="code-definitions" rows="18" spellcheck="false"></textarea>
        <div class="function-call">
            <textarea class="function-call-history" id="code-log" rows="17" readonly></textarea>
            <div>
                <input type="text" class="function-call-input" id="code-prompt" onkeydown="
                    if (event.key == 'Enter') {
                        eval(codeDefinitions.value);
                        lastUserInstruction = codePrompt.value;
                        codeLog.value += codePrompt.value + ' : ' + eval(codePrompt.value) + '\n';
                        codePrompt.value = '';
                        codeLog.scrollTop = codeLog.scrollHeight;
                    }
                    if (event.key == 'ArrowUp') {
                        var newLastUserInstruction = codePrompt.value;
                        codePrompt.value = lastUserInstruction;
                        setTimeout(()=>{
                            codePrompt.selectionStart = 10000;
                            codePrompt.selectionEnd = 10000;
                        }, 0);
                        lastUserInstruction = newLastUserInstruction;
                    }
                " spellcheck="false">
                <button class="function-call-run" onclick="
                    eval(codeDefinitions.value);
                    lastUserInstruction = codePrompt.value;
                    codeLog.value += codePrompt.value + ' : ' + eval(document.getElementById('code-prompt').value) + '\n';
                    codePrompt.value = '';
                    codeLog.scrollTop = codeLog.scrollHeight;
                ">▶</button>
            </div>
        </div>
    </div>
    <script>
        var lastUserInstruction = "";
        var codeLog = document.getElementById('code-log');
        var codePrompt = document.getElementById('code-prompt');
        var codeDefinitions = document.getElementById('code-definitions');
        document.querySelectorAll('.scroll-button').forEach((button) => {
            button.addEventListener('click', () => {
                const card = button.closest('.card');
                const cardsContainer = card.parentElement;
                const cards = Array.from(cardsContainer.children);
                const currentIndex = cards.indexOf(card);
                const isNext = button.classList.contains('forward');
                const targetIndex = isNext ? currentIndex + 1 : currentIndex - 1;
                const targetCard = cards[targetIndex];

                if (targetCard) {
                    targetCard.scrollIntoView({ behavior: 'smooth', block: 'nearest', inline: 'start' });
                }
            });
        });
    </script>
    <style>
        .controll{
            display: flex;
            justify-content: center;
        }
    </style>
</body>
